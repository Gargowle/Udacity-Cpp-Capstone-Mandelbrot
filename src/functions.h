#ifndef FUNCTIONS_H
#define PFUNCTIONS_H


#include <vector>
#include <complex>
#include <functional>
#include "window.h"


void mandelbrot();

void fractal(
	window<int>& scr,
	window<double>& fract,
	int iter_max,
	std::vector<std::vector<int>>& colors,
	const std::function<std::complex<double>(std::complex<double>, std::complex<double>)>& func,
	const char* fname
);

// for each pixel in image check if the point goes to infinity
void get_number_iterations(
	window<int>& scr,
	window<double>& fract,
	int iter_max,
	std::vector<std::vector<int>>& colors,
	const std::function<std::complex<double>(std::complex<double>, std::complex<double>)>& func
);

// returns vector that in each element holds a vector holding the first and last row of the image that needs to be generated by a thread
std::vector<std::tuple<int, int, int>> get_best_possible_split(window<int>& scr);

// get a slice of the mandelbrot image
std::vector<int> get_image_slice(
	int scr_width,
	int scr_height,
	int scr_x_min,
	double fr_width,
	double fr_height,
	double fr_x_min,
	double fr_y_min,
	int slice_y_min,
	int slice_y_max,
	//int already_covered_pixels,
	int iter_max,
	const std::function<std::complex<double>(std::complex<double>, std::complex<double>)>& func
);

// get the complex number equivalent to a given pixel coordinate
std::complex<double> scale(
	int scr_width,
	int scr_height,
	double fr_width,
	double fr_height,
	double fr_x_min,
	double fr_y_min,
	std::complex<double> c
);

// Check if a point is in the mandelbrot set or if the function goes to infinity; returns number of iterations
int escape(
	std::complex<double> c,
	int iter_max,
	const std::function<std::complex<double>(std::complex<double>, std::complex<double>)>& func
);

#endif